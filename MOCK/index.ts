// –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
const NODE_URL =
  "https://neat-tame-pond.btc.quiknode.pro/91ba64a3b7d2ced2d16fff2eb260106323aba0c0";
const TYPES = ["P2PKH", "P2SH", "P2SH-P2WPKH", "P2WPKH", "P2TR"] as const;
type AddressType = (typeof TYPES)[number];

// –†–µ–∑—É–ª—å—Ç–∞—Ç: –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç–∏–ø–∞ —Ö—Ä–∞–Ω–∏–º incoming, outgoing, both
interface ResultEntry {
  incoming?: string;
  outgoing?: string;
  both?: string;
}

const result: Record<AddressType, ResultEntry> = {
  P2PKH: {},
  P2SH: {},
  "P2SH-P2WPKH": {},
  P2WPKH: {},
  P2TR: {},
};

// –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã
interface RpcResponse<T> {
  result: T;
  error: any;
  id: string;
}

interface Vin {
  coinbase?: string;
  txid?: string;
  scriptSig?: {
    asm: string;
    hex: string;
  };
  addresses?: string[];
  txinwitness?: string[];
}

interface Vout {
  scriptPubKey: {
    address?: string;
    addresses?: string[];
    type: string;
    hex: string;
  };
}

interface Tx {
  txid: string;
  vin: Vin[];
  vout: Vout[];
}

interface Block {
  hash: string;
  height: number;
  tx: Tx[];
}

// HTTPS POST-–∑–∞–ø—Ä–æ—Å
function rpcCall<T>(method: string, params: any[] = []): Promise<T> {
  return new Promise((resolve, reject) => {
    const body = JSON.stringify({
      jsonrpc: "2.0",
      method,
      params,
      id: "1",
    });

    const url = new URL(NODE_URL);
    const options = {
      hostname: url.hostname,
      port: url.port,
      path: url.pathname,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Content-Length": Buffer.byteLength(body),
      },
    };

    const req = (
      url.protocol === "https:" ? require("https") : require("http")
    ).request(options, (res) => {
      let data = "";
      res.on("data", (chunk) => (data += chunk));
      res.on("end", () => {
        try {
          const json = JSON.parse(data) as RpcResponse<T>;
          if (json.error) {
            reject(new Error(`RPC Error: ${json.error.message || json.error}`));
          } else {
            resolve(json.result);
          }
        } catch (e) {
          reject(
            new Error(`Parse error: ${e instanceof Error ? e.message : e}`)
          );
        }
      });
    });

    req.on("error", reject);
    req.write(body);
    req.end();
  });
}

// –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –∞–¥—Ä–µ—Å–∞
function classifyAddress(addr: string, vout?: Vout): AddressType | null {
  if (addr.startsWith("1") && /^[1-9a-km-zA-HJ-NP-Z]{25,34}$/.test(addr)) {
    return "P2PKH";
  }
  if (addr.startsWith("3") && /^[1-9a-km-zA-HJ-NP-Z]{25,34}$/.test(addr)) {
    // –ü—Ä–æ–≤–µ—Ä–∏–º, –Ω–µ P2SH-P2WPKH –ª–∏ —ç—Ç–æ
    if (
      vout?.scriptPubKey.hex?.toLowerCase().startsWith("a914") &&
      vout.scriptPubKey.hex.length === 44
    ) {
      const redeemHex = vout.scriptPubKey.hex.slice(4, -2); // –∏–∑–≤–ª–µ–∫–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ
      if (redeemHex.startsWith("0014") && redeemHex.length === 44) {
        return "P2SH-P2WPKH";
      }
    }
    return "P2SH";
  }
  if (addr.startsWith("bc1q") && (addr.length === 42 || addr.length === 62)) {
    return "P2WPKH";
  }
  if (addr.startsWith("bc1p") && addr.length === 62) {
    return "P2TR";
  }
  return null;
}

// –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
async function main() {
  try {
    console.log("–ü–æ–ª—É—á–∞–µ–º –≤—ã—Å–æ—Ç—É –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –±–ª–æ–∫–∞...");
    const blockCount = await rpcCall<number>("getblockcount");
    console.log(`–ü–æ—Å–ª–µ–¥–Ω–∏–π –±–ª–æ–∫: ${blockCount}`);

    const blockHash = await rpcCall<string>("getblockhash", [blockCount]);
    console.log(`–•—ç—à –±–ª–æ–∫–∞: ${blockHash}`);

    const block = await rpcCall<Block>("getblock", [blockHash, 2]);
    console.log(`\n‚úÖ –ë–ª–æ–∫ ${block.height} –∑–∞–≥—Ä—É–∂–µ–Ω.`);
    console.log(`üìä –í—Å–µ–≥–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π –≤ –±–ª–æ–∫–µ: ${block.tx.length}`);

    // –ú–Ω–æ–∂–µ—Å—Ç–≤–∞: –∫—Ç–æ —á—Ç–æ –¥–µ–ª–∞–ª
    const incomingSet = new Set<string>();
    const outgoingSet = new Set<string>();

        // –°–æ–±–∏—Ä–∞–µ–º –≤—Ö–æ–¥—è—â–∏–µ (–≤ vout) –∏ –∏—Å—Ö–æ–¥—è—â–∏–µ (–≤ vin)
    // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π –¥–ª—è –ø–æ–∏—Å–∫–∞ —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–Ω—ã—Ö –∞–¥—Ä–µ—Å–æ–≤
    const txToProcess = block.tx.slice(0, Math.min(1000, block.tx.length));
    console.log(`üîç –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–µ ${txToProcess.length} —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π –∏–∑ ${block.tx.length}`);

    let processedTx = 0;
    let rpcCalls = 0;
    const maxRpcCalls = 200; // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ RPC –≤—ã–∑–æ–≤–æ–≤

    for (const tx of txToProcess) {
      if (tx.vin.length === 1 && tx.vin[0].coinbase) continue;

      // –í—Ö–æ–¥—è—â–∏–µ –∞–¥—Ä–µ—Å–∞ (–ø–æ–ª—É—á–∞—Ç–µ–ª–∏) - –∏–∑ vout
      for (const vout of tx.vout) {
        const addr = vout.scriptPubKey.address;
        if (addr) {
          incomingSet.add(addr);
        }
        if (vout.scriptPubKey.addresses) {
          for (const a of vout.scriptPubKey.addresses) {
            incomingSet.add(a);
          }
        }
      }

      // –ò—Å—Ö–æ–¥—è—â–∏–µ –∞–¥—Ä–µ—Å–∞ (–æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª–∏) - –ø–æ–ª—É—á–∞–µ–º –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
      for (const vin of tx.vin) {
        // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–ª–µ addresses (–µ—Å–ª–∏ –µ—Å—Ç—å)
        if (vin.addresses && Array.isArray(vin.addresses)) {
          for (const addr of vin.addresses) {
            outgoingSet.add(addr);
          }
        } else if (vin.txid && vin.vout !== undefined && rpcCalls < maxRpcCalls) {
          // –ü–æ–ª—É—á–∞–µ–º –∞–¥—Ä–µ—Å –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
          try {
            rpcCalls++;
            const prevTx = await rpcCall<any>("getrawtransaction", [vin.txid, true]);
            if (prevTx && prevTx.vout && prevTx.vout[vin.vout]) {
              const prevOut = prevTx.vout[vin.vout];
              const addr = prevOut.scriptPubKey.address;
              if (addr) {
                outgoingSet.add(addr);
              }
              if (prevOut.scriptPubKey.addresses) {
                for (const a of prevOut.scriptPubKey.addresses) {
                  outgoingSet.add(a);
                }
              }
            }
          } catch (error) {
            // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
            console.debug(`–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø—Ä–µ–¥—ã–¥—É—â—É—é —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é ${vin.txid}`);
          }
        }
      }

      processedTx++;
      if (processedTx % 50 === 0) {
        console.log(`üìà –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π: ${processedTx}/${txToProcess.length}, RPC –≤—ã–∑–æ–≤–æ–≤: ${rpcCalls}/${maxRpcCalls}`);
      }
    }

    console.log(`üìä –ù–∞–π–¥–µ–Ω–æ –≤—Ö–æ–¥—è—â–∏—Ö –∞–¥—Ä–µ—Å–æ–≤: ${incomingSet.size}`);
    console.log(`üìä –ù–∞–π–¥–µ–Ω–æ –∏—Å—Ö–æ–¥—è—â–∏—Ö –∞–¥—Ä–µ—Å–æ–≤: ${outgoingSet.size}`);

    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Å–µ –∞–¥—Ä–µ—Å–∞ –∏ –∑–∞–ø–æ–ª–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    const processedAddresses = new Set<string>();

    // 1. –°–Ω–∞—á–∞–ª–∞ –∏—â–µ–º BOTH –∞–¥—Ä–µ—Å–∞ (–µ—Å—Ç—å –∏ –≤ incoming, –∏ –≤ outgoing)
    for (const addr of incomingSet) {
      if (outgoingSet.has(addr)) {
        const type = classifyAddress(addr);
        if (type && !result[type].both) {
          result[type].both = addr;
          processedAddresses.add(addr);
          console.log(`‚úÖ ${type} BOTH: ${addr}`);
        }
      }
    }

    // 2. –ó–∞—Ç–µ–º –∏—â–µ–º INCOMING ONLY –∞–¥—Ä–µ—Å–∞ (—Ç–æ–ª—å–∫–æ –≤ incoming, –Ω–µ –≤ outgoing)
    for (const addr of incomingSet) {
      if (!outgoingSet.has(addr) && !processedAddresses.has(addr)) {
        const type = classifyAddress(addr);
        if (type && !result[type].incoming) {
          result[type].incoming = addr;
          processedAddresses.add(addr);
          console.log(`üì• ${type} INCOMING: ${addr}`);
        }
      }
    }

    // 3. –ù–∞–∫–æ–Ω–µ—Ü, –∏—â–µ–º OUTGOING ONLY –∞–¥—Ä–µ—Å–∞ (—Ç–æ–ª—å–∫–æ –≤ outgoing, –Ω–µ –≤ incoming)
    for (const addr of outgoingSet) {
      if (!incomingSet.has(addr) && !processedAddresses.has(addr)) {
        const type = classifyAddress(addr);
        if (type && !result[type].outgoing) {
          result[type].outgoing = addr;
          processedAddresses.add(addr);
          console.log(`üì§ ${type} OUTGOING: ${addr}`);
        }
      }
    }

    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
    console.log('\nüìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –∞–¥—Ä–µ—Å–æ–≤:');
    for (const type of TYPES) {
      const entry = result[type];
      const count = (entry.incoming ? 1 : 0) + (entry.outgoing ? 1 : 0) + (entry.both ? 1 : 0);
      console.log(`${type}: ${count}/3 (${entry.incoming ? '‚úÖ' : '‚ùå'}incoming, ${entry.outgoing ? '‚úÖ' : '‚ùå'}outgoing, ${entry.both ? '‚úÖ' : '‚ùå'}both)`);
    }

    // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –≤—ã–≤–æ–¥ –≤ –≤–∏–¥–µ JSON-–æ–±—ä–µ–∫—Ç–æ–≤ –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è
    console.log("\nüì¨ –†–µ–∑—É–ª—å—Ç–∞—Ç (–∫–æ–ø–∏—Ä—É–π –≤ JSON)");

    for (const type of TYPES) {
      const entry = result[type];

      if (entry.both) {
        console.log(`
          {
            "address": "${entry.both}",
            "name": "${entry.both} / ${type} /${entry.both}",
            "note": "${type} (both incoming and outgoing)"
          },`);
      } else {
        if (entry.incoming) {
          console.log(`
            {
              "address": "${entry.incoming}",
              "name": "${entry.incoming} / ${type} /${entry.incoming}",
              "note": "${type} (incoming)"
            },`);
        }
        if (entry.outgoing) {
          console.log(`
            {
              "address": "${entry.outgoing}",
              "name": "${entry.outgoing} / ${type} /${entry.outgoing}",
              "note": "${type} (outgoing)"
            }`);
        }
      }
    }
  } catch (error: any) {
    console.error("‚ùå –û—à–∏–±–∫–∞:", error.message || error);
  }
}

main();
